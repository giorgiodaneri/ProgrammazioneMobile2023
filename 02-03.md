# 02-03

XML è un linguaggio di markup che serve a gestire formattazione delle informazioni (tipo LaTex). 

Il manifest racconta come è fatta l'app, da quali **componenti** è formata. 

L'apk, per funzionare, deve essere firmata. La firma consiste nel fornire la chiave privata, per cui viene rilasciato il file zip e la chiave pubblica per verificare l'identita dello sviluppatore. Questo per accertare pubblicamente l'affidabilità di una certa app agli utenti che desiderano scaricarla. Ciascuno sviluppatore ha chiave pubblica e privata rilasciata contestualmente ad un certificato collegato all'identita della persona. 

Android permette di generare autonomamente tali certificati, per cui non richiede certificazione da parte di ente centralizzato che si occupa della garanzia di identità e affidabilità degli sviluppatori. E' la filosofia open di android, che prevede un mercato liberalizzato. 

Chiave di debug generata da Android Studio, che viene associata a ciascuna apk sviluppata. 

## DEVELOPING THE UI

<img title="" src="file:///C:/Users/giorg/AppData/Roaming/marktext/images/2023-03-02-16-27-11-image.png" alt="" width="215" data-align="inline">

Da quante componenti (label) è composta questa interfaccia? Ci sono 10 oggetti (ci torneremo). La tastiera non appartiene al codice dello sviluppatore, ma è parte delle modalita di interazione con l'interfaccia messa a disposizione dell'utente a posteriori. Si parla di programmazione ad eventi, per cui il programmatore si occupa di ordinare quali servizi vengono offerti all'utente, non programma i servizi in se. Tastiera fa parte di tali servizi che permettono a utente di interagire con l'app, ma la scelta della tipologia di tastiera non ricade sulle spalle dello sviluppatore, bensì sull'SDK (credo vengano implementate in automatico, con la possibilita di cambiamento da parte dell'utente).

Un'app esiste se ha almeno una **schermata**, anche denominata **activity**. Mi servirà un main in java per far partire il programma, contenuto nella rispettiva classe. In generale il main è il primo metodo che viene eseguito, cosi come l'ultimo. Tuttavia noi non vogliamo che app termini da sola, quindi dobbiamo riadattare funzionalita del main a quelle richieste dall'app.

==> la schermata è il main. 

Ciascuna activity sarà una versione custom di un modello generico fornito dall'SDK.  Dove viene disegnata l'interfaccia grafica? Viene definito un **layout**, un contenitore che gestisce la disposizione delle informazioni e aggiunge modalità di interazione. E' il file .xml di cui sopra. 

Quando parte il main, ovvero l'activity, come prima cosa carica il file xml, quindi il layout, che costituisce l'intermediario tra app e utente quanto ad interazione. 

Un **menu** è una lista di liste, ovvero i sottomenu. Ciascuna lista contiene dei menuitem.  Ciascun oggetto grafico avrà il suo corrispettivo oggetto in Java, gestibile attraverso i suoi metodi. Per cui interazione utente scatena invocazione di un metodo particolare. 

Nella schermata piu semplice possibile ho due elementi principali:

- **layouts** 

- **widgets** , aggiunti tramite drag and drop, tuttavia necessitano gestione a monte da parte del programmatore

Sappiamo che un campo è una proprieta di un oggetto, per cui ciascun layout avra una serie di campi customizzabili. Layout sono strutture gerarchiche, pertanto vengono gestiti attraverso **alberi** (performance logaritmiche).

**Gradle** è il compilatore di android, che fornisce anche precompilazione per preview e feedback al programmatore.

Attenzione al passaggio da portrait a landscape, ovvero girare il dispositivo. Questo non ha impatto solamente su gestione layout e interfaccia grafica (che chiaramente necessita di essere adattiva), ma coinvolge anche il sistema operativo per aspetti che vedremo. Ogni oggetto è associato al proprio **id univoco**, ovvero la sua chiave primaria. 

Concetto di **gravità**, ovvero un punto all'interno della schermata rispetto a cui avviene allinemanto degli oggetti del layout. 

Come gestiamo app in lingue diverse, in base al sistema operativo dell'utente che scarica l'apk? Mi serve modalita scalabile della modifica al file. Voglio legare una porzione del testo ad un **tag**, indicato con @, quindi in fase di installazione impongo quale stringa inserire di seguito al tag in base al paese. Per questo motivo fare hard coding risulta deleterio, in quanto tale codice andrebbe riscritto ogni volta a causa della sua incapacità ad adattarsi alle necessita dell'utente. Se non usassi i tag dovrei creare tante istanze del codice quante sono le lingue supportate dall'app, invece che sostituire le stringhe in fase di installazione attingendo da un file XML preposto.  Quindi ciascun tag sarà collegato tramite reference ad una entry del file XML contenente la stringa nella lingua corretta.  

Problema di adattività alla risoluzione dei singoli device, per cui viene introdotto il **dp**, ovvero density-indipendent pixels, dei pixel virtuali utilizzati per definire il layout. I dp vengono tradotti automaticamente in pixel reali a seconda della densità dello schermo del device. Questo processo viene fatto dalle librerie native SGL, che permettono di lavorare in termini di risoluzione unificata. 

#### Proprieta comuni di layout e widget

<img src="file:///C:/Users/giorg/AppData/Roaming/marktext/images/2023-03-02-17-16-18-image.png" title="" alt="" data-align="center">

Le basi sono: la dimensione, ovvero la porzione di schermo ad esso dedicata. Una interfaccia grafica è una concatenazione di layout, ovvero un insieme di regole su come posizionare i widget entro l'activity. Il layout è architettura ad albero, per cui posso inserire in layout dentro un altro, come se fosse suo figlio nella gerarchia definita implicitamente. Quindi per ogni layout posso specificare quale porzione puo occupare del layout padre che lo contiene. C'è meccanismo di match_parent, utilizzato se si vuole dare dimensione massima al layout relativamente al layout padre.  PaddingTop è la distanza dalla cima del layout padre. 

Il concetto di wrap_content consiste nel rendere il layout grande il giusto per contenere gli oggetti posti al suo interno. 

Il widget **ems** è il numero max di caratteri che possono essere inseriti, si basa sulla dimensione massima dei caratteri presa come riferimento, ovvero la dimensione della "m". Questo per specificare la dimensione corrispondente al numero massimo di caratteri che è possibile inserire in una text box, basandosi sul caso pessimo.

<img title="" src="file:///C:/Users/giorg/AppData/Roaming/marktext/images/2023-03-02-17-27-37-image.png" alt="" width="337" data-align="center">

Una schermata è organizzata attraverso una **griglia**, che permette di posizionare in modo preciso gli oggetti. Questo fornisce un principio di scalabilità su device con risoluzioni diverse.
