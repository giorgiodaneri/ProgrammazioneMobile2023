# 07-03

Molti comandi in linux shell prevedono un gran numero di syscall. Tra queste una delle piu comuni è la **fork**, che genera un processo figlio incaricato di svolgere una certa funzione, per cui terminerà una volta completata la task. 

Ci sara necessita di switchare in kernel mode se voglio modificare il contenuto di file, ma non se voglio sapere qual è il contenuto di una directory. Inoltre kernel mode gestisce IPC. Chiamate a sistema in android vengono effettuate tramite puntatori. 

Attenzione alla caratteristica **asincrono** del codice che dobbiamo eseguire, in risposta all'input utente. Un esempio è l'interrupt di sistema, di natura asincrona, che viene generata in seguito a input utente intercettato da una routine di sistema. 

Ogni volta che voglio estendere una activity dovro fare overriding di un certo numero di metodi per customizzare activity di base. Una parte di questi override viene impostata in automatico, tuttavia programmatore deve gestire quando metodi verranno invocati. Questo consiste nell'identificare e intercettare gli eventi che scatenano invocazione di un metodo. 

Prima di tutto devo imporrre esecuzione del file XML contenente io layout di base, su cui viene costruita l'app. Per questo mi affido a **onCreate()** che crea processo al cui interno viene posto codice da eseguire. Activity viene inserita nel processo e creata, ma non ancora visualizzata a schermo. **setContentView** è un metodo che dice cosa deve essere visualizzato a schermo. una volta creata activity devo creare interfaccia compilando il file corrispondente (non ancora visualizzata a schermo).

Una activity può avere un meno, ovvero una lista di item, codificate come entry di un file XML. 

Per specificare posizione di un file non si puo usare un path, perchè equivale a fare hardconding. Aggiornare posizione di un file porta problemi, non si adatta ai cambiamenti in corso d'opera e crasha.

Viene introdotto **sistema di indicizzazione** per identificare i file, mentre Android si occupa di gestire la loro posizione senza che sviluppatore se ne debba preoccupare. **R** indica le **resources**, un folder contenente tutti i file che costituiscono l'app. Quindi ciascun file è costutuito da un certo numero di entries. Ciascuna entry sarà un intero e identifica un file. Ogni votla che creo un nuovo file Gradle si occupa di creare una nuova entry e associarla al file, inserirla all'interno di R.layout. 

Come controllo un oggetto grafico dell'interfaccia mediante codice? Come sono legati? Creo un oggetto java corrispondente a ciascun oggetto interattivo. Analogamente per ciascun widget avrò una classe java da istanziare per creare nuovi oggetti. 

Ecco la dichiarazione:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-14-52-24-image.png)

I widget sono classi native di Android, per cui devo importare le seguenti librerie:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-14-55-48-image.png)

Il legame effettivo tra oggetto java e oggetto grafico avviene tramite la **findViewById**:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-14-54-01-image.png)

Devo effettuare un **down casting** degli oggetti poiche la find ritorna un generico Object, mentre devo istanziarlo con tipo che effettivamente utilizzo.

Ora devo capire quando invocare i metodi che ho definito. Come posso definire un **evento** generato da utente? Il caso piu semplice è un click su interfaccia grafica, per cui bisogna catturarlo e tracciare la sua posizione sullo schermo. Tuttavia un evento puo sortire un qualche tipo di effetto o meno, a seconda della posizione del click sulla schermata. Gli eventi hanno la stessa priorita, tuttavia la reazione viene decisa dal programmatore. Associo alle porzioni di interfaccia di interesse dei **listeners** (anche chiamati **eventi handler**), deputati a intercettare gli eventi generati dall'utente. Una volta catturato l'evento, il listener esegue il codice che gli era stato associato in fase di programmazione. Eppure interfaccia cattura eventi ovunque, ma li ignora qualora non sia presente un listener su tale porzione. Quindi viene generato interrupt in ogni caso. 

Avrò un thread preposto ad intercettare eventi sull'interfaccia, che lo cattura e poi viene distrutto. 

**NB:** applicazioni Android sono single-thread.

Esempio cronometro: thread per aggiornare valore del tempo che scorre, thread che si occupa di aggiornare valore su interfaccia, thread che intercetta eventi utente. 

Bisogna tenere presente la pesantezza computazionale che viene eseguita in risposta ad un certo evento. 

Ci sono tre passi per gestire un evento:

- importare un'interfaccia che definisce un listener

- creare il listener implementando l'interfaccia listener

- connettere il listener al widget

Quanti listener devo definire nel caso seguente?

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-15-19-02-image.png)

Sembrerebbe almeno tre, uno per ciascuna casella interattiva, editText e i due bottoni. Eppure i due bottoni implementano funzionalita molto simili, per cui è sufficiente una singola classe che, a seconda dell'evento, sortisce effetto voluto. 

Non devo dimenticare che nei fatti ho numerose activity, che possono implementare funzionalita analoghe, per cui disporre della medesima classe listener.

Codice del listener è incluso nella libreria **onEditorActionListener**. 

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-15-26-05-image.png)

La classe del listener è ATipCalculatorActivity. Posso tramutare tutta l'activity in listener di tale evento, per non saper ne leggere ne scrivere. 

Quando utente clicca su editText viene invocato **onEditorAction**, che modifica altri oggetti grafici rispetto a quello con cui aveva interagito utente. 

Per collegare listener ad activity, nel caso in cui i due coincidano, è il seguente: 

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-15-33-04-image.png)

Tuttavia in generale bisogna passare come parametro il listener in questione, dato che non coincide con l'activity che monitora. 

Gli high level event sono eventi aggregati, specifici di un certo widget, composti da una serie di eventi low level. Il singolo click appartiene alla seconda categoria. Il metodo definito sopra, che implementa il listener, viene effettivamente invocato quando utente clicca invio dopo aver digitato valori sulla tastiera.

Utilizzo dei getter per intercettare input utente ed poi lo converto eventualmente in una stringa per inserirlo in una variabile. 

Successivamente devo fare **parsing** della stringa utilizzando **classi wrapper**, che contengono insieme di operazioni utili per i tipi base. Di seguito utilizzo parseFloat, che fa parte di questa categoria:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-16-03-30-image.png)

Nella riga di codice seguente NumberFormat è una classe statica e quello invocato è un metodo statico:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-16-05-11-image.png)

Successivamente utilizzo il metodo format per convertire la currency nella valuta utilizzata a seconda del paese da cui proviene utente.

Ora devo gestire interazione con i due bottoni. Cosa cambia rispetto a codice visto per editText? Il modus operandi è lo stesso. 

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-16-12-04-image.png)

Tuttavia in questo caso utilizzo una classe per implementare interfacce multiple e quindi gestire eventi diversi. I problemi nascono nel momento in cui voglio definire un activity leggermente diversa, ma con la stessa struttura, poiche non posso utilizzare i medesimi listener che avevo definito. 

Un listener che ascolta il click prende come parametro la view, ovvero la porzione di interfaccia da esso coperta che è stata interessata dall'evento. 

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-16-21-36-image.png)

#### LIFECYCLE OF AN ACTIVITY

Ricorda che il ciclo di vita di una activity comprende una serie di cambiamenti di stato. In corrispondenza di un cambiamento di stato vengono eseguite delle operazioni. 

Nel passo della creazione dell'activity non è presente in foreground. Una volta che viene eseguita la start viene creata interfaccia grafica, mentre onResume la pone in foreground. La schedulazione verde dipende dall'utente. Lo stato **stopped** dipende invece dal sistema operativo, o meglio dal garbage collector di Java e dalle scelte che opera per liberare la memoria. Quindi una volta che activity è in background l'utente non ha piu potere su di lei, il suo destino è determinato dal sistema operativo. 

Per questo un semplice context switch tra una schermata e un'altra puo causare la distruzione di tale activity da parte del garbage collector. una volta che utente riapre app, activity viene generata da zero, ex novo. Questo non piace all'user experience ==> è fondamentale salvare lo stato dei textView e degli editText per poter rigenerare lo stato cosi come era stato lasciato prima dello switch. In questo modo percezione utente è che activity sia sempre la stessa, mentre è stata ricreata da capo grazie a salvataggio dello stato. 

#### SAVING AND RESTORING VALUES

Uso classe **SharedPreference** per salvare stato activity appena ho cmabiamento di stato in seguito a invocazione di onPause().

**NB:** un socket è un file condiviso da un certo numero di processi che producono o consumano. E' lo stesso concetto che si applica alla SharedPreference.  Creo una sua istanza nella onCreate(), per cui tale oggetto salvera i valori e sarà disponibile solamente all'activity in questione. 

Richiamiamo il concetto di **operazione atomica** da applicare a SharedPreference per evitare che assuma valori inconsistenti. Per questo implemento mutex, semafori o meccanismi simili per mettere in stato locked la risorsa condivisa. 

Per ogni informazione che voglio memorizzare devo salvare chiave e valore nel modo seguente:

![](C:\Users\giorg\AppData\Roaming\marktext\images\2023-03-07-16-41-47-image.png)

Il **commit** è l'operazione atomica per evitare i problemi di cui sopra in fase di scrittura. 

Chiamo super.onPause() che invoca onPause della classe padre per propagare operazione nella gerarchia delle dipendenze. 

Se consulto il manifesto Android della mia app trovo le stesse informazioni che gia conosco, ovvero che è costituita da una main acitivty e altre info simili. 
